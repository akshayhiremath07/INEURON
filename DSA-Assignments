DSA-Assignments
===============
Assignment-1
------------
1) public int[] twoSum(int[] nums, int target) {
        Map < Integer, Integer > seen = new HashMap < > ();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (seen.containsKey(complement)) {
                return new int[] {
                    seen.get(complement), i
                };
            }
            seen.put(nums[i], i);
        }
        return null; 
    }

2)    public int removeElement(int[] nums, int val) {
     int i=0;
        int j=0;
        while(j < nums.length)
        {
            if(nums[j] != val)
            {
                nums[i] = nums[j];
                i++;
            }
            j++;
        }
        return i;
    }
3)    public int searchInsert(int[] nums, int target) {
        int l=0;
        int r=nums.length-1;
        while(l<=r)
        {
            int mid=l+(r-1)/2;
            if(nums[mid]==target) return mid;
           else if(nums[mid]>target){
               r=mid-1;
           }else l=mid+1;
        }
        return l;
    }
4)    public int[] plusOne(int[] digits) {
for (int i = digits.length - 1; i >= 0; i--) {
	if (digits[i] < 9) {
		digits[i]++;
		return digits;
	}
	digits[i] = 0;
}

digits = new int[digits.length + 1];
digits[0] = 1;
return digits;

        
    }
5) public void merge(int[] nums1, int m, int[] nums2, int n) {
        int[] nums1Copy = new int[m];
        for (int i = 0; i < m; i++) {
            nums1Copy[i] = nums1[i];
        }
         int p1 = 0;
        int p2 = 0;
       for (int p = 0; p < m + n; p++) {
           
            if (p2 >= n || (p1 < m && nums1Copy[p1] < nums2[p2])) {
                nums1[p] = nums1Copy[p1++];
            } else {
                nums1[p] = nums2[p2++];
            }
        }
        
    }
6)public boolean containsDuplicate(int[] nums) {
        HashMap<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {
                return true;
            }
            map.put(nums[i],1);
        }
        return false;
        
    }
7)  public void moveZeroes(int[] nums) {
        int n=nums.length;
        int count=0;
        for(int i=0;i<n;i++){
            if(nums[i]!=0){
                swap(i,count,nums);
                count++;
            }
        }

        
    }
    public void swap(int i,int j,int[] nums){
        int temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }
8)  public int[] findErrorNums(int[] nums) {
        int[] res=new int[2];

        HashSet<Integer> set= new HashSet<>();
        int sum=0;
        for(int num: nums){
            if(set.contains(num)){
                res[0]=num;
            }else {
                
                set.add(num);
                 sum+=num;
            
        }
       
        }
        // we got the number which was repeated twice

        int n=nums.length;
        res[1]=(n*(n+1)/2)-(sum);



return res;
    }
    
   ASSIGNMENT-2
    ------------
   1) public int arrayPairSum(int[] nums) {
         Arrays.sort(nums);
        int sum = 0;
        for(int i = 0 ; i < nums.length-1; i= i+2){
            sum = sum+ Math.min(nums[i],nums[i+1]);
        }
        return sum;
    }

2) public int distributeCandies(int[] candyType) {
     
     int n=candyType.length;
     int candysAllowed=n/2;
     if(candysAllowed<=findTypesOfCandy(candyType)){
         return candysAllowed;
     }else return findTypesOfCandy(candyType);

        
    }
    public int findTypesOfCandy(int[] ct){
        Arrays.sort(ct);
        int count=1;
        for(int i=1;i<ct.length;i++){
            if(ct[i]!=ct[i-1]) count++;
        }
        return count;
    }
3) public int findLHS(int[] nums) {
         Map<Integer,Integer> m=new HashMap<>();
        for(int i:nums)
            m.put(i,m.getOrDefault(i,0)+1);
        
        int max=0;
        for(int i:m.keySet())
            if(m.containsKey(i+1)) max=Math.max(max,m.get(i)+m.get(i+1)); 
        
        return max;
    }
4) public boolean canPlaceFlowers(int[] flowerbed, int n) {
         int planted=0;
        for(int i=0;i<flowerbed.length;i++){
            if(flowerbed[i]==0){
              int prev=(i==0||flowerbed[i-1]==0)?0:1;
              int next=((i==flowerbed.length-1) || flowerbed[i+1]==0)?0:1;
              if(prev==0 && next==0) {
                  planted++;
                  flowerbed[i]=1;
              }

            }
        }
        return planted>=n;
       
        
    }
5) public int maximumProduct(int[] nums) {
    
        int maxProduct=Integer.MIN_VALUE;
        int prod=1;
        int left=0;
        for(int i=0;i<3;i++) {
         prod=prod*nums[i];
        }
      maxProduct=  Math.max(prod,maxProduct);
        for(int i=3;i<nums.length;i++){
            prod=prod/nums[left]*nums[i];
            left++;
        }
        maxProduct= Math.max(prod,maxProduct);
        return maxProduct;
        
    }
6) public int search(int[] nums, int target) {
       if(nums.length==0) return -1;

       int l=0;
       int r=nums.length-1;
       while(l<=r){
        int mid=l+(r-l)/2;
        if(nums[mid]==target) return mid;

       else if(nums[mid]>target) r=mid-1;
        else l=mid+1;

       }
       return -1;

        
    }
7) public boolean isMonotonic(int[] nums) {
            for(int i = 0; i < nums.length - 1; i++){
            if(nums[i] < nums[i + 1]) {
                
                for(int j = i + 1; j < nums.length - 1; j++){
                    if(nums[j] > nums[j + 1]) return false;
                }

                return true;
            }else if(nums[i] > nums[i + 1]) {
                
                for(int j = i + 1; j < nums.length - 1; j++){
                    if(nums[j] < nums[j + 1]) return false;
                }

                return true;
            }
        }

        return true;
    }
8) public int smallestRangeI(int[] nums, int k) {
         //find max and min element 
        int max, min;
        max=min=nums[0];
        for(int i=0;i<nums.length;i++){
            max=Math.max(max,nums[i]);
            min=Math.min(min,nums[i]);

        }
        // how will be the difference will be minimum
        // when we max=max-k and min=min+k;

        int diff= (max-k)-(min+k);

        return (diff>0) ? diff : 0;
    }
