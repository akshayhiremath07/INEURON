DSA-Assignments
===============
Assignment-1
------------
1) public int[] twoSum(int[] nums, int target) {
        Map < Integer, Integer > seen = new HashMap < > ();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (seen.containsKey(complement)) {
                return new int[] {
                    seen.get(complement), i
                };
            }
            seen.put(nums[i], i);
        }
        return null; 
    }

2)    public int removeElement(int[] nums, int val) {
     int i=0;
        int j=0;
        while(j < nums.length)
        {
            if(nums[j] != val)
            {
                nums[i] = nums[j];
                i++;
            }
            j++;
        }
        return i;
    }
3)    public int searchInsert(int[] nums, int target) {
        int l=0;
        int r=nums.length-1;
        while(l<=r)
        {
            int mid=l+(r-1)/2;
            if(nums[mid]==target) return mid;
           else if(nums[mid]>target){
               r=mid-1;
           }else l=mid+1;
        }
        return l;
    }
4)    public int[] plusOne(int[] digits) {
for (int i = digits.length - 1; i >= 0; i--) {
	if (digits[i] < 9) {
		digits[i]++;
		return digits;
	}
	digits[i] = 0;
}

digits = new int[digits.length + 1];
digits[0] = 1;
return digits;

        
    }
5) public void merge(int[] nums1, int m, int[] nums2, int n) {
        int[] nums1Copy = new int[m];
        for (int i = 0; i < m; i++) {
            nums1Copy[i] = nums1[i];
        }
         int p1 = 0;
        int p2 = 0;
       for (int p = 0; p < m + n; p++) {
           
            if (p2 >= n || (p1 < m && nums1Copy[p1] < nums2[p2])) {
                nums1[p] = nums1Copy[p1++];
            } else {
                nums1[p] = nums2[p2++];
            }
        }
        
    }
6)public boolean containsDuplicate(int[] nums) {
        HashMap<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {
                return true;
            }
            map.put(nums[i],1);
        }
        return false;
        
    }
7)  public void moveZeroes(int[] nums) {
        int n=nums.length;
        int count=0;
        for(int i=0;i<n;i++){
            if(nums[i]!=0){
                swap(i,count,nums);
                count++;
            }
        }

        
    }
    public void swap(int i,int j,int[] nums){
        int temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }
8)  public int[] findErrorNums(int[] nums) {
        int[] res=new int[2];

        HashSet<Integer> set= new HashSet<>();
        int sum=0;
        for(int num: nums){
            if(set.contains(num)){
                res[0]=num;
            }else {
                
                set.add(num);
                 sum+=num;
            
        }
       
        }
        // we got the number which was repeated twice

        int n=nums.length;
        res[1]=(n*(n+1)/2)-(sum);



return res;
    }
    
   ASSIGNMENT-2
    ------------
   1) public int arrayPairSum(int[] nums) {
         Arrays.sort(nums);
        int sum = 0;
        for(int i = 0 ; i < nums.length-1; i= i+2){
            sum = sum+ Math.min(nums[i],nums[i+1]);
        }
        return sum;
    }

2) public int distributeCandies(int[] candyType) {
     
     int n=candyType.length;
     int candysAllowed=n/2;
     if(candysAllowed<=findTypesOfCandy(candyType)){
         return candysAllowed;
     }else return findTypesOfCandy(candyType);

        
    }
    public int findTypesOfCandy(int[] ct){
        Arrays.sort(ct);
        int count=1;
        for(int i=1;i<ct.length;i++){
            if(ct[i]!=ct[i-1]) count++;
        }
        return count;
    }
3) public int findLHS(int[] nums) {
         Map<Integer,Integer> m=new HashMap<>();
        for(int i:nums)
            m.put(i,m.getOrDefault(i,0)+1);
        
        int max=0;
        for(int i:m.keySet())
            if(m.containsKey(i+1)) max=Math.max(max,m.get(i)+m.get(i+1)); 
        
        return max;
    }
4) public boolean canPlaceFlowers(int[] flowerbed, int n) {
         int planted=0;
        for(int i=0;i<flowerbed.length;i++){
            if(flowerbed[i]==0){
              int prev=(i==0||flowerbed[i-1]==0)?0:1;
              int next=((i==flowerbed.length-1) || flowerbed[i+1]==0)?0:1;
              if(prev==0 && next==0) {
                  planted++;
                  flowerbed[i]=1;
              }

            }
        }
        return planted>=n;
       
        
    }
5) public int maximumProduct(int[] nums) {
    
        int maxProduct=Integer.MIN_VALUE;
        int prod=1;
        int left=0;
        for(int i=0;i<3;i++) {
         prod=prod*nums[i];
        }
      maxProduct=  Math.max(prod,maxProduct);
        for(int i=3;i<nums.length;i++){
            prod=prod/nums[left]*nums[i];
            left++;
        }
        maxProduct= Math.max(prod,maxProduct);
        return maxProduct;
        
    }
6) public int search(int[] nums, int target) {
       if(nums.length==0) return -1;

       int l=0;
       int r=nums.length-1;
       while(l<=r){
        int mid=l+(r-l)/2;
        if(nums[mid]==target) return mid;

       else if(nums[mid]>target) r=mid-1;
        else l=mid+1;

       }
       return -1;

        
    }
7) public boolean isMonotonic(int[] nums) {
            for(int i = 0; i < nums.length - 1; i++){
            if(nums[i] < nums[i + 1]) {
                
                for(int j = i + 1; j < nums.length - 1; j++){
                    if(nums[j] > nums[j + 1]) return false;
                }

                return true;
            }else if(nums[i] > nums[i + 1]) {
                
                for(int j = i + 1; j < nums.length - 1; j++){
                    if(nums[j] < nums[j + 1]) return false;
                }

                return true;
            }
        }

        return true;
    }
8) public int smallestRangeI(int[] nums, int k) {
         //find max and min element 
        int max, min;
        max=min=nums[0];
        for(int i=0;i<nums.length;i++){
            max=Math.max(max,nums[i]);
            min=Math.min(min,nums[i]);

        }
        // how will be the difference will be minimum
        // when we max=max-k and min=min+k;

        int diff= (max-k)-(min+k);

        return (diff>0) ? diff : 0;
    }
Assignment-3
------------
1)  public int threeSumClosest(int[] nums, int target) {
           Arrays.sort(nums);
        int minDistance = Integer.MAX_VALUE;
        int closestSum = 0;

        for(int i = 0; i < nums.length - 2; i++) {
            int start = i + 1;
            int end = nums.length - 1;

            while(start < end) {
                int sum = nums[i] + nums[start] + nums[end];
                int distance = Math.abs(target - sum);

                if(sum == target) {
                    return sum;
                }  

                if(distance < minDistance) {
                    minDistance = distance;
                    closestSum = sum;
                }

                if(sum < target) {
                    start++;
                } else {
                    end--;
                }
            }
        }
        return closestSum;
    }
2) public List<List<Integer>> fourSum(int[] nums, int target) {
               int n=nums.length;
        Arrays.sort(nums);
        List<List<Integer>> ans=new ArrayList<>();
        if(n==0||n<3){
            return ans;
        }
     
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                int low=j+1;
                int high=n-1;
                int sum=target-nums[i]-nums[j];
                while(low<high){
                    if(nums[low]+nums[high]==sum){
                        List<Integer> temp=new ArrayList<>();
                        temp.add(nums[i]);
                        temp.add(nums[j]);
                        temp.add(nums[low]);
                        temp.add(nums[high]);
                        ans.add(temp);
                        while(low<high&&nums[low]==nums[low+1]){
                            low++;
                        }
                        while(low<high&&nums[high]==nums[high-1]){
                            high--;
                        }
                        low++;
                        high--;
                    }
                    else if(nums[low]+nums[high]<sum){
                        low++;
                    }
                    else{
                        high--;
                    }
                }
                while(j+1<n&&nums[j+1]==nums[j]){
                    j++;
                }
            }
            while(i+1<n&&nums[i+1]==nums[i]){
                i++;
            }
        }
        return ans;
    }
3)public void nextPermutation(int[] nums) {
        int i=nums.length-2;
        while(i>=0 && nums[i]>=nums[i+1]) i--;

        if(i>=0){
            int j=nums.length-1;
            while(j>=0 && nums[j]<=nums[i]) j--;

            swap(nums,i,j);
        }
        reverse(nums,i+1);
        
    }
    public void swap(int[] nums,int i,int j){
        int temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }
    public void reverse(int[] nums,int i){
      int start =i;
      int end=nums.length-1;
      while(start<end){
          swap(nums,start,end);
          start++;
          end--;
      }

    }
4> public int searchInsert(int[] nums, int target) {
        int start = 0;
        int end = nums.length-1;

        while (start <= end) {
            int mid = start + (end-start)/2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] > target) end = mid-1;
            else start = mid+1;
        }

        return start;
    }
5) public int[] plusOne(int[] digits) {
for (int i = digits.length - 1; i >= 0; i--) {
	if (digits[i] < 9) {
		digits[i]++;
		return digits;
	}
	digits[i] = 0;
}

digits = new int[digits.length + 1];
digits[0] = 1;
return digits;

        
    }
6)public int singleNumber(int[] nums) {
        int ans=0; //since XOR with 0 returns same number 
        for(int i=0; i<nums.length; i++){
            ans ^= nums[i];  // ans = (ans) XOR (array element at i) 
        }
        return ans;    
    }
7)  public List<String> findMissingRanges(int[] nums, int lower, int upper) {
        List<String> res = new ArrayList<String>();
        int next = lower;
        for (int i = 0; i < nums.length; i++) {
            // 1. We don't need to add [Integer.MAX_VALUE, ...] to result
            if(lower == Integer.MAX_VALUE) return res;
            if (nums[i] < next) {
                continue;
            }
            if (nums[i] == next) {
                next++;
                continue;
            }
            res.add(getRange(next, nums[i] - 1));
            // 2. We don't need to proceed after we have process Integer.MAX_VALUE in array
            if(nums[i] == Integer.MAX_VALUE) return res;
            next = nums[i] + 1;
        }
        
        if (next <= upper) {
            res.add(getRange(next, upper));
        }
        return res;
    }
    
    public String getRange(int n1, int n2) {
        return n1 == n2 ? String.valueOf(n1) : String.format("%d->%d" , n1, n2);
    }
8) public boolean canAttendMeetings(int[][] intervals) {
    Arrays.sort(intervals, new Comparator<int[]>() {
      public int compare(int[] i1, int[] i2) {
        return i1[0] - i2[0];
      }
    });
    for (int i = 0; i < intervals.length - 1; i++) {
      if (intervals[i][1] > intervals[i + 1][0])
        return false;
    }
    return 
Assignment-4
-------------
1)  public List<Integer> arraysIntersection(int[] arr1, int[] arr2, int[] arr3) {
        List<Integer> intersection = new ArrayList<Integer>();
        int length1 = arr1.length, length2 = arr2.length, length3 = arr3.length;
        int index1 = 0, index2 = 0, index3 = 0;
        while (index1 < length1 && index2 < length2 && index3 < length3) {
            int num1 = arr1[index1], num2 = arr2[index2], num3 = arr3[index3];
            if (num1 == num2 && num1 == num3) {
                intersection.add(num1);
                index1++;
                index2++;
                index3++;
            } else {
                int increment1 = 0, increment2 = 0, increment3 = 0;
                if (num1 < num2 || num1 < num3)
                    increment1 = 1;
                if (num2 < num1 || num2 < num3)
                    increment2 = 1;
                if (num3 < num1 || num3 < num2)
                    increment3 = 1;
                index1 += increment1;
                index2 += increment2;
                index3 += increment3;
            }
        }
        return intersection;
    }
2) public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {
        List<List<Integer>> ans = new ArrayList<>();
        HashSet<Integer> set1 = new HashSet<>();
        HashSet<Integer> set2 = new HashSet<>();
          
        for(int i = 0 ; i < nums1.length; i ++){
            set1.add(nums1[i]);
        }
          for(int i = 0 ; i < nums2.length; i ++){
            set2.add(nums2[i]);
        }
         List<Integer> list1 = new ArrayList<>();
          for(int i = 0 ; i < nums1.length; i ++){
            if(!set2.contains(nums1[i]) && !list1.contains(nums1[i])){
                list1.add(nums1[i]);
            }
        }
         ans.add(list1);
          List<Integer> list2 = new ArrayList<>();
          for(int i = 0 ; i < nums2.length; i ++){
            if(!set1.contains(nums2[i]) && !list2.contains(nums2[i])){
                list2.add(nums2[i]);
            }
        }
        ans.add(list2);
        return ans;
        

    }
3)  public int[][] transpose(int[][] matrix) {
        int row=matrix.length;
        int col=matrix[0].length;
        int arr[][]=new int[col][row];
        for(int i=0;i<col;i++)
        {
            for(int j=0;j<row;j++)
            {
            arr[i][j]=matrix[j][i];
            }
        }
        return arr;
        
    }
4) public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        int sum = 0;
        for (int i = 0; i < n; i += 2) {
            sum += nums[i];
        }
        return sum;
    }
5)public int arrangeCoins(int n) {
         int i = 1; // which row we are on
		while(n > 0){ // checking to see if we have used all our coins
			i++; // increasing our row
			n = n-i; // adding coins to our row
		}
		return i-1;
    }
6)  public int[] sortedSquares(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];
        int left = 0;
        int right = n - 1;
        int i = n - 1;

        while (left <= right) {
            int leftSquare = nums[left] * nums[left];
            int rightSquare = nums[right] * nums[right];

            if (leftSquare > rightSquare) {
                result[i] = leftSquare;
                left++;
            } else {
                result[i] = rightSquare;
                right--;
            }

            i--;
        }

        return result;
    }
7) public int maxCount(int m, int n, List<List<Integer>> ops) {
        Map<Integer, Integer> xs = new HashMap<>();
        Map<Integer, Integer> ys = new HashMap<>();

        for (List<Integer> op : ops) {
            for (int i = 1; i <= op.get(0); i++) {
                xs.put(i, xs.getOrDefault(i, 0) + 1);
            }
            for (int j = 1; j <= op.get(1); j++) {
                ys.put(j, ys.getOrDefault(j, 0) + 1);
            }
        }

        int maxX = m;
        int maxY = n;
        int maxXval = 0;
        int maxYval = 0;

        for (Map.Entry<Integer, Integer> entry : xs.entrySet()) {
            int k = entry.getKey();
            int v = entry.getValue();
            if (v >= maxXval) {
                maxX = k;
                maxXval = v;
            }
        }

        for (Map.Entry<Integer, Integer> entry : ys.entrySet()) {
            int k = entry.getKey();
            int v = entry.getValue();
            if (v >= maxYval) {
                maxY = k;
                maxYval = v;
            }
        }

        return maxX * maxY;
    }
8) public int[] shuffle(int[] nums, int n) {
        int[] ans=new int[nums.length];
        int mid=nums.length/2;
        int j=0;
        for(int i=0;i<nums.length;i=i+2){
           ans[i]=nums[j];
           j++;
        }
        j=mid;
         for(int i=1;i<nums.length;i=i+2){
           ans[i]=nums[j];
           j++;
        }
        return ans;
    }
    Assignment-5
------------
1) public int[][] construct2DArray(int[] original, int m, int n) {
        if(m * n != original.length) return new int[][]{};
        int[][] ans=new int[m][n];
        int k=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                ans[i][j]=original[k++];
            }
        }
        return ans;
    }

2)public int arrangeCoins(int n) {
         int i = 1; // which row we are on
		while(n > 0){ // checking to see if we have used all our coins
			i++; // increasing our row
			n = n-i; // adding coins to our row
		}
		return i-1;
    }
3)public int[] sortedSquares(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];
        int left = 0;
        int right = n - 1;
        int i = n - 1;

        while (left <= right) {
            int leftSquare = nums[left] * nums[left];
            int rightSquare = nums[right] * nums[right];

            if (leftSquare > rightSquare) {
                result[i] = leftSquare;
                left++;
            } else {
                result[i] = rightSquare;
                right--;
            }

            i--;
        }

        return result;
    }
4)  public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {
        List<List<Integer>> ans = new ArrayList<>();
        HashSet<Integer> set1 = new HashSet<>();
        HashSet<Integer> set2 = new HashSet<>();
          
        for(int i = 0 ; i < nums1.length; i ++){
            set1.add(nums1[i]);
        }
          for(int i = 0 ; i < nums2.length; i ++){
            set2.add(nums2[i]);
        }
         List<Integer> list1 = new ArrayList<>();
          for(int i = 0 ; i < nums1.length; i ++){
            if(!set2.contains(nums1[i]) && !list1.contains(nums1[i])){
                list1.add(nums1[i]);
            }
        }
         ans.add(list1);
          List<Integer> list2 = new ArrayList<>();
          for(int i = 0 ; i < nums2.length; i ++){
            if(!set1.contains(nums2[i]) && !list2.contains(nums2[i])){
                list2.add(nums2[i]);
            }
        }
        ans.add(list2);
        return ans;
        

    }
5) public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {
        int ans=0;
        for (int i =0;i<arr1.length;i++){
            for (int j =0;j<arr2.length;j++){
                if (Math.abs(arr1[i]-arr2[j])<=d){
                   ans++;
                   break;
                }
            }
        }
        return (arr1.length-ans); 
    }
6)    public List<Integer> findDuplicates(int[] nums) {
       int n = nums.length;
        int[] cs = new int[n+1];
        ArrayList<Integer> al = new ArrayList<>();
        for(int i = 0; i < n; i++){
            cs[nums[i]] += 1;
        }
        for(int i = 0; i < cs.length; i++){
            if(cs[i] == 2){
                al.add(i);
            }
        }
        return al;
    }
        
    }
7)  public int findMin(int[] nums) {
        int n = nums.length;
        int flag = 0;
    
        for(int i=0; i<n-1; i++)
        {
            if(nums[i] > nums[i+1]) {
                flag = 1;
                break;
            }
        }

        if(flag == 0) {
            return nums[0];
        }
        
        int s = 0;
        int e = n-1;
        int mid = s + (e-s)/2;

        while(s<e) 
        {
            if(nums[0] <= nums[mid]) {
                s = mid+1;
            }
            else if(nums[0] > nums[mid]) {
                e = mid;
            }
            mid = s+(e-s)/2;
        }
        return nums[s];
    }
8)public int[] findOriginalArray(int[] changed) {
        
        int len = changed.length;
        if((len&1) != 0) return new int[0];
        
        // Sorting the array
        Arrays.sort(changed);
        
        // Store frequencies in map
        Map<Integer,Integer> map = new HashMap<>();
        for(int e : changed) map.put(e,map.getOrDefault(e,0)+1);
        
        int[] res = new int[len/2];
        int k = 0;
        for(int i=0; i<len; i++){
            int ele = changed[i];
            
            // if map contains 'ele'
            if(map.containsKey(ele)){
                
                // if map contains 'ele*2'
                if(map.containsKey(ele*2)){
                    res[k++] = ele;
                    
                    // reduce frequency of 'ele' and 'ele*2' 
                    map.put(ele,map.get(ele)-1);
                    map.put(ele*2,map.get(ele*2)-1);
                    
                    // if freq of any key becomes <=0, remove it from map 
                    if(map.get(ele)<=0) map.remove(ele);
                    if(map.containsKey(ele*2) && map.get(ele*2)<=0) map.remove(ele*2);
                }
                else return new int[0];
            }
            
        }
        return res;
    }
Assignment-6
-------------
1) public int[] diStringMatch(String s) {
        int[] result = new int[s.length() + 1];
        int end = result.length - 1, start = 0;
        int index = 0;
        while(index < s.length()){
            if(s.charAt(index) == 'I'){
                result[index] = start;   
                start++;
            }else{
                result[index] = end;
                end--;
            }
            index++;
        }
        result[result.length - 1] = start;
        return result;
    }
2)public boolean searchMatrix(int[][] matrix, int target) {
        
     int n=matrix[0].length-1;
     for(int i=0;i<matrix.length;i++){
         if(target<=matrix[i][n]){
             int s=0;
             int e=n;
             while(s<=e){
                 int m=(s+e)/2;
                 if(matrix[i][m]==target) return true;
                 else if(matrix[i][m]<target){
                     s=m+1;
                 }else{
                     e=m-1;
                 }

             }


         }
     }
     return false;
3) public boolean validMountainArray(int[] arr) {
        int n = arr.length;
        if (n < 3) return false; 
        int i = 0;
        while (i < n-1 && arr[i] < arr[i+1]) {
            i++;
        }
        if (i == 0 || i == n-1) return false;
        
        while (i < n-1 && arr[i] > arr[i+1]) {
            i++;
        }
        return i == n-1; 
    }
4) public int findMaxLength(int[] nums) {
        HashMap<Integer,Integer>  hmap = new HashMap<>();
        int maxLength = 0;
        int sum = 0;
        for(int i = 0 ; i < nums.length; i++) {
            sum += (nums[i] == 0 ? -1 : nums[i]);
            if(sum == 0)
                maxLength = i+1;
            else if(hmap.containsKey(sum)) {
                maxLength = Math.max(maxLength,i - hmap.get(sum));
            }
            else 
                hmap.put(sum,i);
        }
        return maxLength;
    }
5) public int minProductSum(int[] nums1, int[] nums2) {
        int ans = 0;
        // Sort nums1 and nums2 in ascending order.
        Arrays.sort(nums2);
        Arrays.sort(nums1);
        
        int i = 0;
        int j = nums2.length-1;
              
        while(i < nums1.length && j >= 0)
        {
            ans += nums1[i] * nums2[j];
            i++;
            j--;
        }
        
        return ans;
    }
6)   public int[] findOriginalArray(int[] changed) {
        
        int len = changed.length;
        if((len&1) != 0) return new int[0];
        
        // Sorting the array
        Arrays.sort(changed);
        
        // Store frequencies in map
        Map<Integer,Integer> map = new HashMap<>();
        for(int e : changed) map.put(e,map.getOrDefault(e,0)+1);
        
        int[] res = new int[len/2];
        int k = 0;
        for(int i=0; i<len; i++){
            int ele = changed[i];
            
            // if map contains 'ele'
            if(map.containsKey(ele)){
                
                // if map contains 'ele*2'
                if(map.containsKey(ele*2)){
                    res[k++] = ele;
                    
                    // reduce frequency of 'ele' and 'ele*2' 
                    map.put(ele,map.get(ele)-1);
                    map.put(ele*2,map.get(ele*2)-1);
                    
                    // if freq of any key becomes <=0, remove it from map 
                    if(map.get(ele)<=0) map.remove(ele);
                    if(map.containsKey(ele*2) && map.get(ele*2)<=0) map.remove(ele*2);
                }
                else return new int[0];
            }
            
        }
        return res;
    }
7)  public int[][] generateMatrix(int n) {
        int [][] a = new int[n][n];
        int l=0,t=0,b=n-1,r=n-1,v=1;
        while(t<=b||l<=r){
         if(t<=b){
             for(int i=l;i<=r;i++)
                a[t][i]=v++;
             t++;
         }
         if(l<=r){
             for(int i=t;i<=b;i++)
                 a[i][r]=v++;
             r--;
         }
         if(t<=b){
             for(int i=r;i>=l;i--)
             a[b][i]=v++;
             b--;
         }
         if(t<=b){
             for(int i=b;i>=t;i--)
             a[i][l]=v++;
         }
         l++;
        }
        return a;
    }
8)public int[][] multiply(int[][] mat1, int[][] mat2) {
        int r1 = mat1.length, c1 = mat1[0].length, c2 = mat2[0].length;
        int[][] res = new int[r1][c2];
        Map<Integer, List<Integer>> mp = new HashMap<>();
        for (int i = 0; i < r1; ++i) {
            for (int j = 0; j < c1; ++j) {
                if (mat1[i][j] != 0) {
                    mp.computeIfAbsent(i, k -> new ArrayList<>()).add(j);
                }
            }
        }
        for (int i = 0; i < r1; ++i) {
            for (int j = 0; j < c2; ++j) {
                if (mp.containsKey(i)) {
                    for (int k : mp.get(i)) {
                        res[i][j] += mat1[i][k] * mat2[k][j];
                    }
                }
            }
        }
        return res;
    }
